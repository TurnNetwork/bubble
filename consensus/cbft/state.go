package cbft

import (
	"github.com/PlatONnetwork/PlatON-Go/common"
	"github.com/PlatONnetwork/PlatON-Go/core/types"
	"sync/atomic"
)

type view struct {
	epoch      uint64
	viewNumber uint64

	//viewchange received by the current view
	viewChanges viewChanges

	//This view has been sent to other verifiers for voting
	hadSendPrepareVote prepareVotes

	//Pending votes of current view, parent block need receive N-f prepareVotes
	pendingVote prepareVotes

	//Current view of the proposed block by the proposer
	viewBlocks viewBlocks

	//The current view generated by the vote
	viewVotes viewVotes
}

func (v *view) Reset() {
	v.epoch = 0
	v.viewNumber = 0
	v.viewChanges.Clear()
	v.hadSendPrepareVote.Clear()
	v.pendingVote.Clear()
	v.viewBlocks.Clear()
	v.viewVotes.Clear()
}

//The block of current view, there two types, prepareBlock and block
type viewBlock interface {
	hash() common.Hash
	number() uint64
	blockIndex() uint32
	//If prepareBlock is an implementation of viewBlock, return prepareBlock, otherwise nil
	prepareBlock() *prepareBlock
}

type viewState struct {

	//Include ViewNumber, viewChanges, prepareVote , proposal block of current view
	*view

	//Highest executed block height
	highestExecutedBlock atomic.Value

	highestQCBlock     atomic.Value
	highestLockBlock   atomic.Value
	highestCommitBlock atomic.Value

	//Set the timer of the view time window
	viewTimer viewTimer
}

func (vs *viewState) ResetView(epoch uint64, viewNumber uint64) {
	vs.view.Reset()
	vs.view.epoch = epoch
	vs.view.viewNumber = viewNumber
}

func (vs *viewState) SetHighestExecutedBlock(block *types.Block) {
	vs.highestExecutedBlock.Store(block)
}

func (vs *viewState) HighestExecutedBlock() *types.Block {
	if v := vs.highestQCBlock.Load(); v == nil {
		panic("Get highest executed block failed")
	} else {
		return v.(*types.Block)
	}
}

func (vs *viewState) SetHighestQCBlock(ext *types.Block) {
	vs.highestQCBlock.Store(ext)
}

func (vs *viewState) HighestQCBlock() *types.Block {
	if v := vs.highestQCBlock.Load(); v == nil {
		panic("Get highest qc block failed")
	} else {
		return v.(*types.Block)
	}
}

func (vs *viewState) SetHighestLockBlock(ext *types.Block) {
	vs.highestLockBlock.Store(ext)
}

func (vs *viewState) HighestLockBlock() *types.Block {
	if v := vs.highestLockBlock.Load(); v == nil {
		panic("Get highest lock block failed")
	} else {
		return v.(*types.Block)
	}
}

func (vs *viewState) SetHighestCommitBlock(ext *types.Block) {
	vs.highestCommitBlock.Store(ext)
}

func (vs *viewState) HighestCommitBlock() *types.Block {
	if v := vs.highestCommitBlock.Load(); v == nil {
		panic("Get highest commit block failed")
	} else {
		return v.(*types.Block)
	}
}
